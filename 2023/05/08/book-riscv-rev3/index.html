<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>book-riscv-rev3 | Mark4z's blog</title><meta name="author" content="Mark4z Lv"><meta name="copyright" content="Mark4z Lv"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Notice: It’s a copy of book-riscv-rev3.pdf Chapter 1 Operating system interfacesThe job of an operating system is to share a computer among multiple programs and to provide a more useful set of servic">
<meta property="og:type" content="article">
<meta property="og:title" content="book-riscv-rev3">
<meta property="og:url" content="http://mark4z.github.io/2023/05/08/book-riscv-rev3/index.html">
<meta property="og:site_name" content="Mark4z&#39;s blog">
<meta property="og:description" content="Notice: It’s a copy of book-riscv-rev3.pdf Chapter 1 Operating system interfacesThe job of an operating system is to share a computer among multiple programs and to provide a more useful set of servic">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://mark4z.github.io/images/cat.jpg">
<meta property="article:published_time" content="2023-05-08T07:19:20.000Z">
<meta property="article:modified_time" content="2023-05-08T08:07:26.863Z">
<meta property="article:author" content="Mark4z Lv">
<meta property="article:tag" content="os">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://mark4z.github.io/images/cat.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://mark4z.github.io/2023/05/08/book-riscv-rev3/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'book-riscv-rev3',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-08 16:07:26'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/cat.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Mark4z's blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">book-riscv-rev3</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-08T07:19:20.000Z" title="发表于 2023-05-08 15:19:20">2023-05-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-08T08:07:26.863Z" title="更新于 2023-05-08 16:07:26">2023-05-08</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="book-riscv-rev3"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><strong>Notice: It’s a copy of <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2022/xv6/book-riscv-rev3.pdf">book-riscv-rev3.pdf</a></strong></p>
<h1 id="Chapter-1-Operating-system-interfaces"><a href="#Chapter-1-Operating-system-interfaces" class="headerlink" title="Chapter 1 Operating system interfaces"></a>Chapter 1 Operating system interfaces</h1><p>The job of an operating system is to share a computer among multiple programs and to provide a more useful set of services than the hardware alone supports. An operating system manages and abstracts the low-level hardware, so that, for example, a word processor need not concern itself with which type of disk hardware is being used. An operating system shares the hardware among multiple programs so that they run (or appear to run) at the same time. Finally, operating systems provide controlled ways for programs to interact, so that they can share data or work together.</p>
<p>An operating system provides services to user programs through an interface. Designing a good interface turns out to be difficult. On the one hand, we would like the interface to be simple and narrow because that makes it easier to get the implementation right. On the other hand, we may be tempted to offer many sophisticated features to applications. The trick in resolving this tension is to design interfaces that rely on a few mechanisms that can be combined to provide much generality.</p>
<p>This book uses a single operating system as a concrete example to illustrate operating system concepts. That operating system, xv6, provides the basic interfaces introduced by Ken Thompson and Dennis Ritchie’s Unix operating system [17], as well as mimicking Unix’s internal design.</p>
<p>Unix provides a narrow interface whose mechanisms combine well, offering a surprising degree of generality. This interface has been so successful that modern operating systems—BSD, Linux, macOS, Solaris, and even, to a lesser extent, Microsoft Windows—have Unix-like interfaces. Understanding xv6 is a good start toward understanding any of these systems and many others.</p>
<p>As Figure 1.1 shows, xv6 takes the traditional form of a kernel, a special program that provides services to running programs. Each running program, called a process, has memory containing instructions, data, and a stack. The instructions implement the program’s computation. The data are the variables on which the computation acts. The stack organizes the program’s procedure calls.</p>
<p>A given computer typically has many processes but only a single kernel.</p>
<p>When a process needs to invoke a kernel service, it invokes a system call, one of the calls in the operating system’s interface. The system call enters the kernel; the kernel performs the service and returns. Thus a process alternates between executing in user space and kernel space.</p>
<p>As described in detail in subsequent chapters, the kernel uses the hardware protection mechanisms provided by a CPU<a href="#ftn1">[1]</a> to ensure that each process executing in user space can access only</p>
<p><img src="/2023/05/08/book-riscv-rev3/1.1.png" alt="Figure-1.1"></p>
<p>its own memory. The kernel executes with the hardware privileges required to implement these protections; user programs execute without those privileges. When a user program invokes a system call, the hardware raises the privilege level and starts executing a pre-arranged function in the kernel.</p>
<p>The collection of system calls that a kernel provides is the interface that user programs see. The xv6 kernel provides a subset of the services and system calls that Unix kernels traditionally offer.</p>
<p>Figure 1.2 lists all of xv6’s system calls.</p>
<p>The rest of this chapter outlines xv6’s services—processes, memory, file descriptors, pipes, and a file system—and illustrates them with code snippets and discussions of how the shell, Unix’s command-line user interface, uses them. The shell’s use of system calls illustrates how carefully they have been designed.</p>
<p>The shell is an ordinary program that reads commands from the user and executes them. The fact that the shell is a user program, and not part of the kernel, illustrates the power of the system call interface: there is nothing special about the shell. It also means that the shell is easy to replace; as a result, modern Unix systems have a variety of shells to choose from, each with its own user interface and scripting features. The xv6 shell is a simple implementation of the essence of the</p>
<p>Unix Bourne shell. Its implementation can be found at (user&#x2F;sh.c:1).</p>
<ol>
<li><a name="ftn1">This text generally refers to the hardware element that executes a computation with the term CPU, an acronym for central processing unit. Other documentation (e.g., the RISC-V specification) also uses the words processor, core,<br> and hart instead of CPU.</a></li>
</ol>
<h2 id="1-1-Processes-and-memory"><a href="#1-1-Processes-and-memory" class="headerlink" title="1.1 Processes and memory"></a>1.1 Processes and memory</h2><p>An xv6 process consists of user-space memory (instructions, data, and stack) and per-process state private to the kernel. Xv6 time-shares processes: it transparently switches the available CPUs among the set of processes waiting to execute. When a process is not executing, xv6 saves the process’s CPU registers, restoring them when it next runs the process. The kernel associates a process identifier, or PID, with each process.</p>
<p>A process may create a new process using the fork system call. fork gives the new process an exact copy of the calling process’s memory, both instructions and data. fork returns in both the original and new processes. In the original process, fork returns the new process’s PID. In the new process, fork returns zero. The original and new processes are often called the parent and child.</p>
<table>
<thead>
<tr>
<th>System call</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><strong>int fork()</strong></td>
<td>Create a process, return child’s PID.</td>
</tr>
<tr>
<td><strong>int exit(int status)</strong></td>
<td>Terminate the current process; status reported to wait(). No return.</td>
</tr>
<tr>
<td><strong>int wait(int *status)</strong></td>
<td>Wait for a child to exit; exit status in *status; returns child PID.</td>
</tr>
<tr>
<td><strong>int kill(int pid)</strong></td>
<td>Terminate process PID. Returns 0, or -1 for error.</td>
</tr>
<tr>
<td><strong>int getpid()</strong></td>
<td>Return the current process’s PID.</td>
</tr>
<tr>
<td><strong>int sleep(int n)</strong></td>
<td>Pause for n clock ticks.</td>
</tr>
<tr>
<td><strong>int exec(char *file, char *argv[])</strong></td>
<td>Load a file and execute it with arguments; only returns if error.</td>
</tr>
<tr>
<td><strong>char *sbrk(int n)</strong></td>
<td>Grow process’s memory by n bytes. Returns start of new memory.</td>
</tr>
<tr>
<td><strong>int open(char *file, int flags)</strong></td>
<td>Open a file; flags indicate read&#x2F;write; returns an fd (file descriptor).</td>
</tr>
<tr>
<td><strong>int write(int fd, char *buf, int n)</strong></td>
<td>Write n bytes from buf to file descriptor fd; returns n.</td>
</tr>
<tr>
<td><strong>int read(int fd, char *buf, int n)</strong></td>
<td>Read n bytes into buf; returns number read; or 0 if end of file.</td>
</tr>
<tr>
<td><strong>int close(int fd)</strong></td>
<td>Release open file fd.</td>
</tr>
<tr>
<td><strong>int dup(int fd)</strong></td>
<td>Return a new file descriptor referring to the same file as fd.</td>
</tr>
<tr>
<td><strong>int pipe(int p[])</strong></td>
<td>Create a pipe, put read&#x2F;write file descriptors in p[0] and p[1].</td>
</tr>
<tr>
<td><strong>int chdir(char *dir)</strong></td>
<td>Change the current directory.</td>
</tr>
<tr>
<td><strong>int mkdir(char *dir)</strong></td>
<td>Create a new directory.</td>
</tr>
<tr>
<td><strong>int mknod(char *file, int, int)</strong></td>
<td>Create a device file.</td>
</tr>
<tr>
<td><strong>int fstat(int fd, struct stat *st)</strong></td>
<td>Place info about an open file into *st.</td>
</tr>
<tr>
<td><strong>int stat(char *file, struct stat *st)</strong></td>
<td>Place info about a named file into *st.</td>
</tr>
<tr>
<td><strong>int link(char *file1, char *file2)</strong></td>
<td>Create another name (file2) for the file file1.</td>
</tr>
<tr>
<td><strong>int unlink(char *file)</strong></td>
<td>Remove a file.</td>
</tr>
</tbody></table>
<p>Figure 1.2: Xv6 system calls. If not otherwise stated, these calls return 0 for no error, and -1 if there’s an error.</p>
<p>For example, consider the following program fragment written in the C programming language [7]:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: child=%d\n&quot;</span>, pid);</span><br><span class="line">    pid = wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child %d is done\n&quot;</span>, pid);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child: exiting\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The exit system call causes the calling process to stop executing and to release resources such as memory and open files. Exit takes an integer status argument, conventionally 0 to indicate success and 1 to indicate failure. The wait system call returns the PID of an exited (or killed) child of the current process and copies the exit status of the child to the address passed to wait; if none of the caller’s children has exited, wait waits for one to do so. If the caller has no children, wait immediately returns -1. If the parent doesn’t care about the exit status of a child, it can pass a 0 address to wait.</p>
<p>In the example, the output lines</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parent: child=1234</span><br><span class="line">child: exiting</span><br></pre></td></tr></table></figure>
<p>might come out in either order (or even intermixed), depending on whether the parent or child gets to its printf call first. After the child exits, the parent’s wait returns, causing the parent to print parent: child 1234 is done</p>
<p>Although the child has the same memory contents as the parent initially, the parent and child are executing with separate memory and separate registers: changing a variable in one does not affect the other. For example, when the return value of wait is stored into pid in the parent process, it doesn’t change the variable pid in the child. The value of pid in the child will still be zero.</p>
<p>The exec system call replaces the calling process’s memory with a new memory image loaded from a file stored in the file system. The file must have a particular format, which specifies which part of the file holds instructions, which part is data, at which instruction to start, etc. Xv6 uses the ELF format, which Chapter 3 discusses in more detail. Usually the file is the result of compiling a program’s source code. When exec succeeds, it does not return to the calling program; instead, the instructions loaded from the file start executing at the entry point declared in the ELF header. exec takes two arguments: the name of the file containing the executable and an array of string arguments. For example:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *argv[<span class="number">3</span>];</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;echo&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">argv[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">exec(<span class="string">&quot;/bin/echo&quot;</span>, argv);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;exec error\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>This fragment replaces the calling program with an instance of the program &#x2F;bin&#x2F;echo running with the argument list echo hello. Most programs ignore the first element of the argument array, which is conventionally the name of the program.</p>
<p>The xv6 shell uses the above calls to run programs on behalf of users. The main structure of the shell is simple; see main (user&#x2F;sh.c:146). The main loop reads a line of input from the user with getcmd. Then it calls fork, which creates a copy of the shell process. The parent calls wait, while the child runs the command. For example, if the user had typed “echo hello” to the shell, runcmd would have been called with “echo hello” as the argument. runcmd (user&#x2F;sh.c:55) runs the actual command. For “echo hello”, it would call exec (user&#x2F;sh.c:79). If exec succeeds then the child will execute instructions from echo instead of runcmd. At some point echo will call exit, which will cause the parent to return from wait in main (user&#x2F;sh.c:146).</p>
<p>You might wonder why fork and exec are not combined in a single call; we will see later that the shell exploits the separation in its implementation of I&#x2F;O redirection. To avoid the wastefulness of creating a duplicate process and then immediately replacing it (with exec), operating kernels optimize the implementation of fork for this use case by using virtual memory techniques such as copy-on-write (see Section 4.6).</p>
<p>Xv6 allocates most user-space memory implicitly: fork allocates the memory required for the child’s copy of the parent’s memory, and exec allocates enough memory to hold the executable file. A process that needs more memory at run-time (perhaps for malloc) can call sbrk(n) to grow its data memory by n bytes; sbrk returns the location of the new memory.</p>
<h2 id="1-2-I-x2F-O-and-File-descriptors"><a href="#1-2-I-x2F-O-and-File-descriptors" class="headerlink" title="1.2 I&#x2F;O and File descriptors"></a>1.2 I&#x2F;O and File descriptors</h2><p>A file descriptor is a small integer representing a kernel-managed object that a process may read<br>from or write to. A process may obtain a file descriptor by opening a file, directory, or device,<br>or by creating a pipe, or by duplicating an existing descriptor. For simplicity we’ll often refer<br>to the object a file descriptor refers to as a “file”; the file descriptor interface abstracts away the<br>differences between files, pipes, and devices, making them all look like streams of bytes. We’ll<br>refer to input and output as I&#x2F;O.<br>Internally, the xv6 kernel uses the file descriptor as an index into a per-process table, so that<br>every process has a private space of file descriptors starting at zero. By convention, a process reads<br>from file descriptor 0 (standard input), writes output to file descriptor 1 (standard output), and<br>writes error messages to file descriptor 2 (standard error). As we will see, the shell exploits the<br>convention to implement I&#x2F;O redirection and pipelines. The shell ensures that it always has three<br>file descriptors open (user&#x2F;sh.c:152), which are by default file descriptors for the console.<br>The read and write system calls read bytes from and write bytes to open files named by file<br>descriptors. The call read(fd, buf, n) reads at most n bytes from the file descriptor fd, copies<br>them into buf, and returns the number of bytes read. Each file descriptor that refers to a file has an<br>offset associated with it. read reads data from the current file offset and then advances that offset<br>by the number of bytes read: a subsequent read will return the bytes following the ones returned<br>by the first read. When there are no more bytes to read, read returns zero to indicate the end of<br>the file.<br>The call write(fd, buf, n) writes n bytes from buf to the file descriptor fd and returns the<br>number of bytes written. Fewer than n bytes are written only when an error occurs. Like read,<br>write writes data at the current file offset and then advances that offset by the number of bytes<br>written: each write picks up where the previous one left off.<br>The following program fragment (which forms the essence of the program cat) copies data<br>from its standard input to its standard output. If an error occurs, it writes a message to the standard<br>error.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">512</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="number">13</span></span><br><span class="line">    n = read(<span class="number">0</span>, buf, <span class="keyword">sizeof</span> buf);</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;read error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(write(<span class="number">1</span>, buf, n) != n)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;write error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The important thing to note in the code fragment is that cat doesn’t know whether it is reading<br>from a file, console, or a pipe. Similarly cat doesn’t know whether it is printing to a console, a<br>file, or whatever. The use of file descriptors and the convention that file descriptor 0 is input and<br>file descriptor 1 is output allows a simple implementation of cat.<br>The close system call releases a file descriptor, making it free for reuse by a future open,<br>pipe, or dup system call (see below). A newly allocated file descriptor is always the lowestnumbered unused descriptor of the current process.<br>File descriptors and fork interact to make I&#x2F;O redirection easy to implement. fork copies<br>the parent’s file descriptor table along with its memory, so that the child starts with exactly the<br>same open files as the parent. The system call exec replaces the calling process’s memory but<br>preserves its file table. This behavior allows the shell to implement I&#x2F;O redirection by forking, reopening chosen file descriptors in the child, and then calling exec to run the new program. Here<br>is a simplified version of the code a shell runs for the command cat &lt; input.txt:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *argv[<span class="number">2</span>];</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;cat&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(fork() == <span class="number">0</span>) &#123;</span><br><span class="line">    close(<span class="number">0</span>);</span><br><span class="line">    open(<span class="string">&quot;input.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    exec(<span class="string">&quot;cat&quot;</span>, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>After the child closes file descriptor 0, open is guaranteed to use that file descriptor for the newly<br>opened input.txt: 0 will be the smallest available file descriptor. cat then executes with file<br>descriptor 0 (standard input) referring to input.txt. The parent process’s file descriptors are not<br>changed by this sequence, since it modifies only the child’s descriptors.<br>The code for I&#x2F;O redirection in the xv6 shell works in exactly this way (user&#x2F;sh.c:83). Recall that<br>at this point in the code the shell has already forked the child shell and that runcmd will call exec<br>to load the new program.<br>The second argument to open consists of a set of flags, expressed as bits, that control what<br>open does. The possible values are defined in the file control (fcntl) header (kernel&#x2F;fcntl.h:1-5):</p>
<p>O_RDONLY, O_WRONLY, O_RDWR, O_CREATE, and O_TRUNC, which instruct open to open the file<br>for reading, or for writing, or for both reading and writing, to create the file if it doesn’t exist, and<br>to truncate the file to zero length.<br>Now it should be clear why it is helpful that fork and exec are separate calls: between the<br>two, the shell has a chance to redirect the child’s I&#x2F;O without disturbing the I&#x2F;O setup of the main<br>shell. One could instead imagine a hypothetical combined forkexec system call, but the options<br>for doing I&#x2F;O redirection with such a call seem awkward. The shell could modify its own I&#x2F;O<br>setup before calling forkexec (and then un-do those modifications); or forkexec could take<br>instructions for I&#x2F;O redirection as arguments; or (least attractively) every program like cat could<br>be taught to do its own I&#x2F;O redirection.<br>Although fork copies the file descriptor table, each underlying file offset is shared between<br>parent and child. Consider this example:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(fork() == <span class="number">0</span>) &#123;</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;hello &quot;</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;world\n&quot;</span>, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>At the end of this fragment, the file attached to file descriptor 1 will contain the data hello world.<br>The write in the parent (which, thanks to wait, runs only after the child is done) picks up where<br>the child’s write left off. This behavior helps produce sequential output from sequences of shell<br>commands, like (echo hello; echo world) &gt;output.txt.<br>The dup system call duplicates an existing file descriptor, returning a new one that refers to<br>the same underlying I&#x2F;O object. Both file descriptors share an offset, just as the file descriptors<br>duplicated by fork do. This is another way to write hello world into a file:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fd = dup(<span class="number">1</span>);</span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;hello &quot;</span>, <span class="number">6</span>);</span><br><span class="line">write(fd, <span class="string">&quot;world\n&quot;</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>
<p>Two file descriptors share an offset if they were derived from the same original file descriptor<br>by a sequence of fork and dup calls. Otherwise file descriptors do not share offsets, even if they<br>resulted from open calls for the same file. dup allows shells to implement commands like this:<br>ls existing-file non-existing-file &gt; tmp1 2&gt;&amp;1. The 2&gt;&amp;1 tells the shell to give the<br>command a file descriptor 2 that is a duplicate of descriptor 1. Both the name of the existing file<br>and the error message for the non-existing file will show up in the file tmp1. The xv6 shell doesn’t<br>support I&#x2F;O redirection for the error file descriptor, but now you know how to implement it.<br>File descriptors are a powerful abstraction, because they hide the details of what they are connected to: a process writing to file descriptor 1 may be writing to a file, to a device like the console,<br>or to a pipe.</p>
<h2 id="1-3-Pipes"><a href="#1-3-Pipes" class="headerlink" title="1.3 Pipes"></a>1.3 Pipes</h2><p>A pipe is a small kernel buffer exposed to processes as a pair of file descriptors, one for reading<br>and one for writing. Writing data to one end of the pipe makes that data available for reading from<br>the other end of the pipe. Pipes provide a way for processes to communicate.<br>The following example code runs the program wc with standard input connected to the read<br>end of a pipe.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> *argv[<span class="number">2</span>];</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;wc&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">pipe(p);</span><br><span class="line"><span class="keyword">if</span>(fork() == <span class="number">0</span>) &#123;</span><br><span class="line">    close(<span class="number">0</span>);</span><br><span class="line">    dup(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">    exec(<span class="string">&quot;/bin/wc&quot;</span>, argv);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    close(p[<span class="number">0</span>]);</span><br><span class="line">    write(p[<span class="number">1</span>], <span class="string">&quot;hello world\n&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    close(p[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The program calls pipe, which creates a new pipe and records the read and write file descriptors<br>in the array p. After fork, both parent and child have file descriptors referring to the pipe. The<br>child calls close and dup to make file descriptor zero refer to the read end of the pipe, closes the<br>file descriptors in p, and calls exec to run wc. When wc reads from its standard input, it reads from<br>the pipe. The parent closes the read side of the pipe, writes to the pipe, and then closes the write<br>side.<br>If no data is available, a read on a pipe waits for either data to be written or for all file descriptors referring to the write end to be closed; in the latter case, read will return 0, just as if the end of<br>a data file had been reached. The fact that read blocks until it is impossible for new data to arrive<br>is one reason that it’s important for the child to close the write end of the pipe before executing<br>wc above: if one of wc ’s file descriptors referred to the write end of the pipe, wc would never see<br>end-of-file.<br>The xv6 shell implements pipelines such as grep fork sh.c | wc -l in a manner similar<br>to the above code (user&#x2F;sh.c:101). The child process creates a pipe to connect the left end of the<br>pipeline with the right end. Then it calls fork and runcmd for the left end of the pipeline and<br>fork and runcmd for the right end, and waits for both to finish. The right end of the pipeline<br>may be a command that itself includes a pipe (e.g., a | b | c), which itself forks two new child<br>processes (one for b and one for c). Thus, the shell may create a tree of processes. The leaves of this tree are commands and the interior nodes are processes that wait until the left and right<br>children complete.<br>Pipes may seem no more powerful than temporary files: the pipeline</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> hello world | <span class="built_in">wc</span></span><br></pre></td></tr></table></figure>
<p>could be implemented without pipes as</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> hello world &gt;/tmp/xyz; <span class="built_in">wc</span> &lt;/tmp/xyz</span><br></pre></td></tr></table></figure>
<p>Pipes have at least three advantages over temporary files in this situation. First, pipes automatically<br>clean themselves up; with the file redirection, a shell would have to be careful to remove &#x2F;tmp&#x2F;xyz<br>when done. Second, pipes can pass arbitrarily long streams of data, while file redirection requires<br>enough free space on disk to store all the data. Third, pipes allow for parallel execution of pipeline<br>stages, while the file approach requires the first program to finish before the second starts.</p>
<h2 id="1-4-File-system"><a href="#1-4-File-system" class="headerlink" title="1.4 File system"></a>1.4 File system</h2><p>The xv6 file system provides data files, which contain uninterpreted byte arrays, and directories,<br>which contain named references to data files and other directories. The directories form a tree,<br>starting at a special directory called the root. A path like &#x2F;a&#x2F;b&#x2F;c refers to the file or directory<br>named c inside the directory named b inside the directory named a in the root directory &#x2F;. Paths<br>that don’t begin with &#x2F; are evaluated relative to the calling process’s current directory, which can<br>be changed with the chdir system call. Both these code fragments open the same file (assuming<br>all the directories involved exist):</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chdir(<span class="string">&quot;/a&quot;</span>);</span><br><span class="line">chdir(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">open(<span class="string">&quot;c&quot;</span>, O_RDONLY);</span><br><span class="line">open(<span class="string">&quot;/a/b/c&quot;</span>, O_RDONLY);</span><br></pre></td></tr></table></figure>
<p>The first fragment changes the process’s current directory to &#x2F;a&#x2F;b; the second neither refers to nor<br>changes the process’s current directory.<br>There are system calls to create new files and directories: mkdir creates a new directory, open<br>with the O_CREATE flag creates a new data file, and mknod creates a new device file. This example<br>illustrates all three:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir(<span class="string">&quot;/dir&quot;</span>);</span><br><span class="line">fd = open(<span class="string">&quot;/dir/file&quot;</span>, O_CREATE|O_WRONLY);</span><br><span class="line">close(fd);</span><br><span class="line">mknod(<span class="string">&quot;/console&quot;</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>mknod creates a special file that refers to a device. Associated with a device file are the major and<br>minor device numbers (the two arguments to mknod), which uniquely identify a kernel device.<br>When a process later opens a device file, the kernel diverts read and write system calls to the<br>kernel device implementation instead of passing them to the file system.</p>
<p>A file’s name is distinct from the file itself; the same underlying file, called an inode, can have<br>multiple names, called links. Each link consists of an entry in a directory; the entry contains a file<br>name and a reference to an inode. An inode holds metadata about a file, including its type (file or<br>directory or device), its length, the location of the file’s content on disk, and the number of links to<br>a file.<br>The fstat system call retrieves information from the inode that a file descriptor refers to. It<br>fills in a struct stat, defined in stat.h (kernel&#x2F;stat.h) as:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> T_DIR 1 <span class="comment">// Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_FILE 2 <span class="comment">// File</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_DEVICE 3 <span class="comment">// Device</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> dev; <span class="comment">// File system’s disk device</span></span><br><span class="line">    uint ino; <span class="comment">// Inode number</span></span><br><span class="line">    <span class="type">short</span> type; <span class="comment">// Type of file</span></span><br><span class="line">    <span class="type">short</span> nlink; <span class="comment">// Number of links to file</span></span><br><span class="line">    uint64 size; <span class="comment">// Size of file in bytes</span></span><br><span class="line">&#125;;</span><br><span class="line">The link system call creates another file system name referring to the same inode as an existing file. This fragment creates a new file named both a and b.</span><br><span class="line">open(<span class="string">&quot;a&quot;</span>, O_CREATE|O_WRONLY);</span><br><span class="line">link(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>Reading from or writing to a is the same as reading from or writing to b. Each inode is identified<br>by a unique inode number. After the code sequence above, it is possible to determine that a and b<br>refer to the same underlying contents by inspecting the result of fstat: both will return the same<br>inode number (ino), and the nlink count will be set to 2.<br>The unlink system call removes a name from the file system. The file’s inode and the disk<br>space holding its content are only freed when the file’s link count is zero and no file descriptors<br>refer to it. Thus adding</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlink(<span class="string">&quot;a&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>to the last code sequence leaves the inode and file content accessible as b. Furthermore,</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">&quot;/tmp/xyz&quot;</span>, O_CREATE|O_RDWR);</span><br><span class="line">unlink(<span class="string">&quot;/tmp/xyz&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>is an idiomatic way to create a temporary inode with no name that will be cleaned up when the<br>process closes fd or exits.<br>Unix provides file utilities callable from the shell as user-level programs, for example mkdir,<br>ln, and rm. This design allows anyone to extend the command-line interface by adding new userlevel programs. In hindsight this plan seems obvious, but other systems designed at the time of<br>Unix often built such commands into the shell (and built the shell into the kernel).<br>One exception is cd, which is built into the shell (user&#x2F;sh.c:161). cd must change the current<br>working directory of the shell itself. If cd were run as a regular command, then the shell would fork a child process, the child process would run cd, and cd would change the child ’s working<br>directory. The parent’s (i.e., the shell’s) working directory would not change.</p>
<h2 id="1-5-Real-world"><a href="#1-5-Real-world" class="headerlink" title="1.5 Real world"></a>1.5 Real world</h2><p>Unix’s combination of “standard” file descriptors, pipes, and convenient shell syntax for operations<br>on them was a major advance in writing general-purpose reusable programs. The idea sparked a<br>culture of “software tools” that was responsible for much of Unix’s power and popularity, and the<br>shell was the first so-called “scripting language.” The Unix system call interface persists today in<br>systems like BSD, Linux, and macOS.<br>The Unix system call interface has been standardized through the Portable Operating System<br>Interface (POSIX) standard. Xv6 is not POSIX compliant: it is missing many system calls (including basic ones such as lseek), and many of the system calls it does provide differ from the<br>standard. Our main goals for xv6 are simplicity and clarity while providing a simple UNIX-like<br>system-call interface. Several people have extended xv6 with a few more system calls and a simple C library in order to run basic Unix programs. Modern kernels, however, provide many more<br>system calls, and many more kinds of kernel services, than xv6. For example, they support networking, windowing systems, user-level threads, drivers for many devices, and so on. Modern<br>kernels evolve continuously and rapidly, and offer many features beyond POSIX.<br>Unix unified access to multiple types of resources (files, directories, and devices) with a single<br>set of file-name and file-descriptor interfaces. This idea can be extended to more kinds of resources;<br>a good example is Plan 9 [16], which applied the “resources are files” concept to networks, graphics, and more. However, most Unix-derived operating systems have not followed this route.<br>The file system and file descriptors have been powerful abstractions. Even so, there are other<br>models for operating system interfaces. Multics, a predecessor of Unix, abstracted file storage in a<br>way that made it look like memory, producing a very different flavor of interface. The complexity<br>of the Multics design had a direct influence on the designers of Unix, who aimed to build something<br>simpler.<br>Xv6 does not provide a notion of users or of protecting one user from another; in Unix terms,<br>all xv6 processes run as root.<br>This book examines how xv6 implements its Unix-like interface, but the ideas and concepts<br>apply to more than just Unix. Any operating system must multiplex processes onto the underlying<br>hardware, isolate processes from each other, and provide mechanisms for controlled inter-process<br>communication. After studying xv6, you should be able to look at other, more complex operating<br>systems and see the concepts underlying xv6 in those systems as well.</p>
<h2 id="1-6-Exercises"><a href="#1-6-Exercises" class="headerlink" title="1.6 Exercises"></a>1.6 Exercises</h2><ol>
<li>Write a program that uses UNIX system calls to “ping-pong” a byte between two processes<br>over a pair of pipes, one for each direction. Measure the program’s performance, in exchanges per second.</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://mark4z.github.io">Mark4z Lv</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://mark4z.github.io/2023/05/08/book-riscv-rev3/">http://mark4z.github.io/2023/05/08/book-riscv-rev3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://mark4z.github.io" target="_blank">Mark4z's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/os/">os</a></div><div class="post_share"><div class="social-share" data-image="/images/cat.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/05/08/hello-world/"><img class="prev-cover" src="/images/cat.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Hello World</div></div></a></div><div class="next-post pull-right"><a href="/2023/05/07/xv6-riscv-book/"><img class="next-cover" src="/images/cat.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">unix-like操作系统 xv6-riscv</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/05/05/ostep/" title="读《操作系统导论》的一些随想"><img class="cover" src="/images/cat.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-05</div><div class="title">读《操作系统导论》的一些随想</div></div></a></div><div><a href="/2023/05/07/xv6-riscv-book/" title="unix-like操作系统 xv6-riscv"><img class="cover" src="/images/cat.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-07</div><div class="title">unix-like操作系统 xv6-riscv</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Mark4z Lv</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/mark4z"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/mark4z" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:mark4z@apache.org" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-1-Operating-system-interfaces"><span class="toc-number">1.</span> <span class="toc-text">Chapter 1 Operating system interfaces</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-Processes-and-memory"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 Processes and memory</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-I-x2F-O-and-File-descriptors"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 I&#x2F;O and File descriptors</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-Pipes"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 Pipes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-File-system"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 File system</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-Real-world"><span class="toc-number">1.5.</span> <span class="toc-text">1.5 Real world</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-Exercises"><span class="toc-number">1.6.</span> <span class="toc-text">1.6 Exercises</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/05/08/hello-world/" title="Hello World"><img src="/images/cat.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/2023/05/08/hello-world/" title="Hello World">Hello World</a><time datetime="2023-05-08T08:07:26.863Z" title="发表于 2023-05-08 16:07:26">2023-05-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/08/book-riscv-rev3/" title="book-riscv-rev3"><img src="/images/cat.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="book-riscv-rev3"/></a><div class="content"><a class="title" href="/2023/05/08/book-riscv-rev3/" title="book-riscv-rev3">book-riscv-rev3</a><time datetime="2023-05-08T07:19:20.000Z" title="发表于 2023-05-08 15:19:20">2023-05-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/07/xv6-riscv-book/" title="unix-like操作系统 xv6-riscv"><img src="/images/cat.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="unix-like操作系统 xv6-riscv"/></a><div class="content"><a class="title" href="/2023/05/07/xv6-riscv-book/" title="unix-like操作系统 xv6-riscv">unix-like操作系统 xv6-riscv</a><time datetime="2023-05-07T08:29:33.000Z" title="发表于 2023-05-07 16:29:33">2023-05-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/05/ostep/" title="读《操作系统导论》的一些随想"><img src="/images/cat.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="读《操作系统导论》的一些随想"/></a><div class="content"><a class="title" href="/2023/05/05/ostep/" title="读《操作系统导论》的一些随想">读《操作系统导论》的一些随想</a><time datetime="2023-05-05T15:29:44.000Z" title="发表于 2023-05-05 23:29:44">2023-05-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/02/nginx-http2/" title="谈谈Http2-为什么nginx在http2下的表现远弱于http1.1"><img src="/images/cat.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="谈谈Http2-为什么nginx在http2下的表现远弱于http1.1"/></a><div class="content"><a class="title" href="/2023/04/02/nginx-http2/" title="谈谈Http2-为什么nginx在http2下的表现远弱于http1.1">谈谈Http2-为什么nginx在http2下的表现远弱于http1.1</a><time datetime="2023-04-02T06:05:46.000Z" title="发表于 2023-04-02 14:05:46">2023-04-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Mark4z Lv</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>